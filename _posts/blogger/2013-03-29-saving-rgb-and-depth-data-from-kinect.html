---
title: "Saving RGB and Depth Data from Kinect as an Image (with OpenNI)"
layout: "post"
permalink: "/2013/04/saving-rgb-and-depth-data-from-kinect.html"
uuid: "3467095140616665963"
guid: "tag:blogger.com,1999:blog-4627720939429298175.post-3467095140616665963"
date: "2013-03-29 01:15:00"
updated: "2013-04-22 03:25:51"
description: 
blogger:
    siteid: "4627720939429298175"
    postid: "3467095140616665963"
    comments: "0"
categories: [development, kinect]
author: 
    name: "Gremsi"
    url: "http://www.blogger.com/profile/00614962079213173450?rel=author"
    image: "http://img2.blogblog.com/img/b16-rounded.gif"
---

<div class="css-full-post-content js-full-post-content">
<div dir="ltr" style="text-align: left;" trbidi="on"><br /><b>This is not my work, I am reposting it just incase if it gets removed. Source:&nbsp;<a href="https://groups.google.com/forum/?fromgroups=#!msg/openni-dev/iYtcrrA365U/wEFT2_-mH0wJ">https://groups.google.com/forum/?fromgroups=#!msg/openni-dev/iYtcrrA365U/wEFT2_-mH0wJ</a></b><br /><br />Hi all,<br />I am working on foreground segmentation using kinect. I needed to<br />extract the color and depth images in a synchronized and registerd way<br />and This thread has been very useful for me. I write you the code I<br />have used to do it, if someone need to do the same:<br /><br />I started modifying the NiViewer sample code you can find in:<br />/OpenNI/Platform/Linux-x86/Redist/Samples/NiViewer<br /><br />Then, I modified some of their files to achieve the .jpg recording<br />jointly with the .oni file. To save the images, I have used opencv<br />library.<br /><br />extract RGB images &nbsp;(in Device.cpp):<br /><br />&nbsp;//new includes:<br />#include "cv.h"<br />#include "highgui.h"<br />#include "sstream"<br />#include "string"<br /><br />//jaume. New function to save RGB frames in jpg format.<br /><br />void saveFrame_RGB(int num)<br />{<br />&nbsp; &nbsp; cv::Mat colorArr[3];<br />&nbsp; &nbsp; cv::Mat colorImage;<br />&nbsp; &nbsp; const XnRGB24Pixel* pImageRow;<br />&nbsp; &nbsp; const XnRGB24Pixel* pPixel;<br /><br />// &nbsp; &nbsp; ImageMetaData* g_ImageMD = getImageMetaData();<br />&nbsp; &nbsp; g_Image.GetMetaData(g_ImageMD);<br />&nbsp; &nbsp; pImageRow = g_ImageMD.RGB24Data();<br /><br />&nbsp; &nbsp; colorArr[0] = cv::Mat(g_ImageMD.YRes(),g_ImageMD.XRes(),CV_8U);<br />&nbsp; &nbsp; colorArr[1] = cv::Mat(g_ImageMD.YRes(),g_ImageMD.XRes(),CV_8U);<br />&nbsp; &nbsp; colorArr[2] = cv::Mat(g_ImageMD.YRes(),g_ImageMD.XRes(),CV_8U);<br /><br />&nbsp; &nbsp; for (int y=0; y&lt;g_ImageMD.YRes(); y++)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; pPixel = pImageRow;<br />&nbsp; &nbsp; &nbsp; uchar* Bptr = colorArr[0].ptr&lt;uchar&gt;(y);<br />&nbsp; &nbsp; &nbsp; uchar* Gptr = colorArr[1].ptr&lt;uchar&gt;(y);<br />&nbsp; &nbsp; &nbsp; uchar* Rptr = colorArr[2].ptr&lt;uchar&gt;(y);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(int x=0;x&lt;g_ImageMD.XRes();++x , ++pPixel)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bptr[x] = pPixel-&gt;nBlue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gptr[x] = pPixel-&gt;nGreen;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rptr[x] = pPixel-&gt;nRed;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; pImageRow += g_ImageMD.XRes();<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; cv::merge(colorArr,3,colorImage);<br /><br />&nbsp; &nbsp; char framenumber[10];<br />&nbsp; &nbsp; sprintf(framenumber,"%06d",num);<br /><br /><br />&nbsp; &nbsp; std::stringstream ss;<br />&nbsp; &nbsp; std::string str_frame_number;<br />// &nbsp; &nbsp; char c = 'a';<br />&nbsp; &nbsp; ss &lt;&lt; framenumber;<br />&nbsp; &nbsp; ss &gt;&gt; str_frame_number;<br /><br />&nbsp; &nbsp; std::string str_aux = "CapturedFrames/image_RGB_"+<br />str_frame_number +".jpg";<br />&nbsp; &nbsp; IplImage bgrIpl = colorImage; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// create a<br />IplImage header for the cv::Mat bgrImage<br />&nbsp; &nbsp; cvSaveImage(str_aux.c_str(),&amp;bgrIpl); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// save it with the<br />old<br /><br />}<br /><br />extract Depth images &nbsp;(in Draw.cpp):<br /><br />&nbsp;//new includes:<br />#include "cv.h"<br />#include "highgui.h"<br /><br />//jaume. New function to save depth map in jpg format. I have based<br />this implementation on the draw images function.<br /><br />void saveFrame_depth(int num)<br />{<br />&nbsp; const DepthMetaData* pDepthMD = getDepthMetaData();<br />&nbsp; const XnDepthPixel* pDepth = pDepthMD-&gt;Data();<br />&nbsp; XN_ASSERT(pDepth);<br /><br />&nbsp; &nbsp;cv::Mat depthImage;<br />&nbsp; &nbsp;cv::Mat colorArr[3];<br /><br />&nbsp; &nbsp; colorArr[0] = cv::Mat(pDepthMD-&gt;YRes(),pDepthMD-&gt;XRes(),CV_8U);<br />&nbsp; &nbsp; colorArr[1] = cv::Mat(pDepthMD-&gt;YRes(),pDepthMD-&gt;XRes(),CV_8U);<br />&nbsp; &nbsp; colorArr[2] = cv::Mat(pDepthMD-&gt;YRes(),pDepthMD-&gt;XRes(),CV_8U);<br /><br /><br />&nbsp; for (XnUInt16 nY = pDepthMD-&gt;YOffset(); nY &lt; pDepthMD-&gt;YRes() +<br />pDepthMD-&gt;YOffset(); nY++)<br />&nbsp; {<br />&nbsp; &nbsp; XnUInt8* pTexture = TextureMapGetLine(&amp;g_texDepth, nY) + pDepthMD-<br />&gt;XOffset()*4;<br /><br />&nbsp; &nbsp; &nbsp; uchar* Bptr = colorArr[0].ptr&lt;uchar&gt;(nY);<br />&nbsp; &nbsp; &nbsp; uchar* Gptr = colorArr[1].ptr&lt;uchar&gt;(nY);<br />&nbsp; &nbsp; &nbsp; uchar* Rptr = colorArr[2].ptr&lt;uchar&gt;(nY);<br /><br />&nbsp; &nbsp; for (XnUInt16 nX = 0; nX &lt; pDepthMD-&gt;XRes(); nX++, pDepth++,<br />pTexture+=4)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XnUInt8 nRed = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XnUInt8 nGreen = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XnUInt8 nBlue = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XnUInt8 nAlpha = g_DrawConfig.Streams.Depth.fTransparency*255;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XnUInt16 nColIndex;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch (g_DrawConfig.Streams.Depth.Coloring)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case LINEAR_HISTOGRAM:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlue = nRed = nGreen = g_pDepthHist[*pDepth]*255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PSYCHEDELIC_SHADES:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nAlpha *= (((XnFloat)(*pDepth % 10) / 20) + 0.5);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PSYCHEDELIC:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch ((*pDepth/10) % 10)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 0:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRed = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 1:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGreen = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 2:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlue = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 3:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRed = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGreen = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 4:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGreen = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlue = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 5:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRed = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlue = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 6:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRed = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGreen = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlue = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 7:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRed = 127;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlue = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 8:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRed = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlue = 127;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 9:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRed = 127;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGreen = 255;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case RAINBOW:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nColIndex = (XnUInt16)((*pDepth / (g_fMaxDepth / 256)));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRed = PalletIntsR[nColIndex];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGreen = PalletIntsG[nColIndex];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlue = PalletIntsB[nColIndex];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case CYCLIC_RAINBOW:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nColIndex = (*pDepth % 256);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRed = PalletIntsR[nColIndex];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGreen = PalletIntsG[nColIndex];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlue = PalletIntsB[nColIndex];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bptr[nX] = nBlue ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gptr[nX] = nGreen;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rptr[nX] = nRed;<br /><br /><br />&nbsp; &nbsp; }<br />&nbsp; }<br /><br />&nbsp; &nbsp;cv::merge(colorArr,3, depthImage);<br /><br /><br />&nbsp; &nbsp; char framenumber[10];<br />&nbsp; &nbsp; sprintf(framenumber,"%06d",num);<br /><br /><br />&nbsp; &nbsp; std::stringstream ss;<br />&nbsp; &nbsp; std::string str_frame_number;<br /><br />&nbsp; &nbsp; ss &lt;&lt; framenumber;<br />&nbsp; &nbsp; ss &gt;&gt; str_frame_number;<br /><br />&nbsp; &nbsp;//CapturedFrames folder must exist!!!<br />&nbsp; &nbsp; std::string str_aux = "CapturedFrames/image_depth_"+<br />str_frame_number +".jpg";<br /><br />&nbsp; &nbsp;IplImage bgrIpl = depthImage; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// create a<br />IplImage header for the cv::Mat bgrImage<br />&nbsp; &nbsp;cvSaveImage(str_aux.c_str(),&amp;bgrIpl); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// save it with the<br />old<br /><br />}<br /><br /><br /><br />File where I use these new functionalities: Capture.cpp.<br /><br /><br />//New include:<br />#include &lt;iostream&gt;<br /><br />//Function modified to save frames in jpg format:<br />XnStatus captureFrame()<br />{<br />&nbsp; &nbsp; &nbsp; &nbsp; XnStatus nRetVal = XN_STATUS_OK;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (g_Capture.State == SHOULD_CAPTURE)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XnUInt64 nNow;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xnOSGetTimeStamp(&amp;nNow);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nNow /= 1000;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nNow &gt;= g_Capture.nStartOn)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_Capture.nCapturedFrames = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_Capture.State = CAPTURING;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (g_Capture.State == CAPTURING)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRetVal = g_Capture.pRecorder-&gt;Record();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XN_IS_STATUS_OK(nRetVal);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //start.jaume<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saveFrame_RGB(g_Capture.nCapturedFrames);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saveFrame_depth(g_Capture.nCapturedFrames);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //end.jaume<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_Capture.nCapturedFrames++;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return XN_STATUS_OK;<br />}<br /><br />To test the code, you must execute the new NiViewer app, and use the<br />options Capture-&gt;start that appear just clicking in the left mouse<br />button.<br /><br />It's all, I hope this code will be useful.<br /><br />Jaume</div>
</div>